using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.Loader;

namespace Scotec.Revit.Loader;

internal class RevitAssemblyLoadContext : AssemblyLoadContext
{{
    private readonly string _pluginRoot;
    private readonly Dictionary<string, string> _assemblyFullNameMap;
    private readonly Dictionary<string, string> _assemblyNameMap;
    private readonly AssemblyDependencyResolver _resolver;

    public RevitAssemblyLoadContext(string contextName, string pluginRoot) : base(contextName)
    {{
        _pluginRoot = Path.GetFullPath(pluginRoot);
        _assemblyFullNameMap = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
        _assemblyNameMap = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
        _resolver = new AssemblyDependencyResolver(pluginRoot);

        CacheAssemblies();
    }}

    protected override Assembly Load(AssemblyName assemblyName)
    {{
        System.Diagnostics.Debug.WriteLine($"Try loading assembly {{assemblyName.FullName}} from ALC '{{Name}}'.");

        // 1. Let AssemblyDependencyResolver resolve first
        var resolvedPath = _resolver.ResolveAssemblyToPath(assemblyName);
        if (resolvedPath != null)
        {{
            // If ADR resolves into a "runtimes" folder, we know this is the RID-specific copy.
            if (resolvedPath.Contains($"{{Path.DirectorySeparatorChar}}runtimes{{Path.DirectorySeparatorChar}}"))
            {{
                System.Diagnostics.Debug.WriteLine($"[ALC:{{Name}}] Using RID-specific assembly from: {{resolvedPath}}");
                return LoadFromAssemblyPath(resolvedPath);
            }}
        }}

         // 2. If ADR returned a root-level assembly, only accept it if no RID-specific variant exists.
        if (resolvedPath != null)
        {{
            var runtimesDir = Path.Combine(_pluginRoot, "runtimes");
            var runtimeSpecificExists = Directory.Exists(runtimesDir) &&
                Directory.EnumerateFiles(runtimesDir, assemblyName.Name + ".dll", SearchOption.AllDirectories).Any();

            if (!runtimeSpecificExists)
            {{
                System.Diagnostics.Debug.WriteLine($"[ALC:{{Name}}] Using assembly resolved by ADR (no RID-specific override): {{resolvedPath}}");
                return LoadFromAssemblyPath(resolvedPath);
            }}
        }}

        // 3. Fallback: check plugin root cache (manual scan from CacheAssemblies)
        if (_assemblyFullNameMap.TryGetValue(assemblyName.FullName, out var path) ||
                _assemblyNameMap.TryGetValue(assemblyName.Name, out path))        
        {{
            System.Diagnostics.Debug.WriteLine($"Assembly '{{assemblyName.FullName}}' found at '{{path}}'.");
            return LoadFromAssemblyPath(path);
        }}

        // 4. Fallback: if ADR gave us *something* (root-level), use it last
        if (resolvedPath != null)
        {{
            System.Diagnostics.Debug.WriteLine($"[ALC:{{Name}}] Fallback to ADR-resolved assembly: {{resolvedPath}}");
            return LoadFromAssemblyPath(resolvedPath);
        }}

        // 5. Let the framework handle unresolved assemblies
        System.Diagnostics.Debug.WriteLine($"[ALC:{{Name}}] Could not resolve {{assemblyName.FullName}}");
        return null;
    }}

    private void CacheAssemblies()
    {{
        foreach (var file in Directory.EnumerateFiles(_pluginRoot, "*.dll", SearchOption.TopDirectoryOnly))
        {{
            try
            {{
                var assemblyName = AssemblyName.GetAssemblyName(file);

                if (!_assemblyFullNameMap.ContainsKey(assemblyName.FullName))
                {{
                    _assemblyFullNameMap.Add(assemblyName.FullName, file);
                    if (!_assemblyNameMap.ContainsKey(assemblyName.Name!))
                    {{
                        _assemblyNameMap.Add(assemblyName.Name!, file);
                    }}
                }}
                else
                {{
                    System.Diagnostics.Debug.WriteLine(
                        $"[Warning] Duplicate assembly identity '{{assemblyName.FullName}}' found at: {{file}}. " +
                        $"Using first occurrence: {{_assemblyFullNameMap[assemblyName.FullName]}}"
                    );
                }}
            }}
            catch (BadImageFormatException)
            {{
                // Not a managed .NET assembly (likely a native DLL) → skip
            }}
            catch (FileLoadException)
            {{
                // The file exists but is not a valid .NET assembly → skip
            }}
        }}
    }}

    protected override IntPtr LoadUnmanagedDll(string unmanagedDllName)
    {{
        var libraryPath = _resolver.ResolveUnmanagedDllToPath(unmanagedDllName);
        if (libraryPath != null)
        {{
            return LoadUnmanagedDllFromPath(libraryPath);
        }}

        return IntPtr.Zero;
    }}
}}
